{"version":3,"sources":["../worker.js","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/0","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/2"],"names":[],"mappings":"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","sourcesContent":["let sheet, errs, vals;\nself.onmessage = ({data})=>{\n  [sheet, errs, vals] = [ data, {}, {} ];\n\n  for (const coord in sheet) {\n    // Four variable names pointing to the same coordinate: A1, a1, $A1, $a1\n    for (const name of [ for (p of [ '', '$' ])\n                           for (c of [ coord, coord.toLowerCase() ])\n                             p+c ]) {\n      // Worker is reused across computations, so only define each variable once\n      if ((Object.getOwnPropertyDescriptor( self, name ) || {}).get) { continue; }\n\n      // Define self['A1'], which is the same thing as the global variable A1\n      Object.defineProperty( self, name, { get() {\n        if (coord in vals) { return vals[coord]; }\n        vals[coord] = NaN;\n\n        // Turn numeric strings into numbers, so =A1+C1 works when both are numbers\n        let x = +sheet[coord];\n        if (sheet[coord] !== x.toString()) { x = sheet[coord]; }\n\n        // Evaluate formula cells that begin with =\n        try { vals[coord] = (('=' === x[0]) ? eval.call( null, x.slice( 1 ) ) : x);\n        } catch (e) {\n          const match = /\\$?[A-Za-z]+[1-9][0-9]*\\b/.exec( e );\n          if (match && !( match[0] in self )) {\n            // The formula refers to a uninitialized cell; set it to 0 and retry\n            self[match[0]] = 0;\n            delete vals[coord];\n            return self[coord];\n          }\n          // Otherwise, stringify the caught exception in the errs object\n          errs[coord] = e.toString();\n        }\n\n        // Turn vals[coord] into a string if it's not a number or boolean\n        switch (typeof vals[coord]) { case 'function': case 'object': vals[coord]+=''; }\n        return vals[coord];\n      } } );\n    }\n  }\n\n  // For each coordinate in the sheet, call the property getter defined above\n  for (const coord in sheet) { self[coord]; }\n  postMessage([ errs, vals ]);\n}\n","\n        for (var $__placeholder__0 =\n                 $__placeholder__1[Symbol.iterator](),\n                 $__placeholder__2;\n             !($__placeholder__3 = $__placeholder__4.next()).done; ) {\n          $__placeholder__5;\n          $__placeholder__6;\n        }","var $__placeholder__0 = 0, $__placeholder__1 = [];","$__placeholder__0[$__placeholder__1++] = $__placeholder__2;","return $__placeholder__0;"]}
